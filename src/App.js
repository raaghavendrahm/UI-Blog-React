import Navbar from './components/Navbar';
import Home from './components/Home';
import { useState } from 'react';
import { useEffect } from 'react';

function App() {
  // Initial state of blogs to display on homepage:
  const [blogs, setBlogs] = useState([]);

  // While data is being fetched, a loading messages must be displayed:
  const [isLoading, setIsLoading] = useState(true);

  // In case of any error while fetching data:
  const [error, setError] = useState(null);

  /* 
  // Delete Blog
  const handleDelete = (id) => {
    const newBlogs = blogs.filter((blog) => blog.id !== id);
    setBlogs(newBlogs);

    // Tasks whose id is not as same as the one which is deleted are displayed. Because filter returns the ones whose condition is true.

    // This deletes blogs only from UI, not from database (server). So, on page refresh, they appear back. This is fixed with json-server later.
  }; 
  */

  // Fetch Blogs
  useEffect(() => {
    // In this case, data is fetched from local machine. So, it is very fast. But, in actual case, data will be fetched from a server over the internet, which will be having a delay. So, to mimic that, 'setTimeOut' function is used to mimic a delay of one second. Note that it shall not be done in an actual project as it adds another second of delay!!

    setTimeout(() => {
      fetch('http://localhost:5000/blogs')
        // Note that, for simulating errors 'blogs' is changed to anything else like 'blogss' in the fetch url above.

        .then((res) => {
          // There could be errors in two ways. One, if the request has not reached the server at all, other is if the request has reached the server and server sent the response object but it has some errors or issues. In first case, error will be automatically generated by system. In the second case, "ok" property of response object must be checked if it is "true". If not, an error must be "thrown" which will be caught in ".catch" and displayed on the browser:

          if (!res.ok) {
            throw Error('Could not fetch the data');
          }

          return res.json();
        })
        .then((data) => {
          setBlogs(data);
          setIsLoading(false);

          // With subsequent request to server after errors, data could be fetched. On successful data fetch, the error state must be set back to null:
          setError(null);
        })
        .catch((err) => {
          // In case of an error, loading msg is not to be displayed:
          setIsLoading(false);

          // Value of message to be set to 'error' state:
          setError(err.message);
        });
    }, 1000);
  }, []);

  /*
  // The above can be done using Async/Await as well as follows:
  
  useEffect(() => {
    const fetchTasks = async () => {
      const res = await fetch('http://localhost:5000/blogs');
      const data = await res.json();
      setBlogs(data);
    };
    fetchTasks();
  }); 
  */

  return (
    <div className="App">
      <Navbar />
      <div className="content">
        {/* In case of any error while fetching data, error message is displayed: */}
        {error && <div>{error}</div>}

        {/* While data is not yet fetched, value of 'isLoading' state will be 'true' and this condition should display 'Loading...' message: */}
        {isLoading && <div>Loading...</div>}

        {/* Once the data is fetched, the value of 'isLoading' state must be changed to 'false' and that should stop diplaying 'Loading...' message. This is taken care in 'Fetch Blogs' section. */}

        <Home blogs={blogs} />
      </div>
    </div>
  );
}

export default App;
