// useFetch is a custom hook created by us to fetch data from any url so that this will be more reusable. When a custom hook is created, its name should start as 'use' so that react understands this js file as a hook. Hook is also a function, which is exported at the end. Note it returns some values as any other hook would do.

import { useState } from 'react';
import { useEffect } from 'react';

const useFetch = (url) => {
  // Initial state of blogs to display on homepage:
  const [data, setData] = useState([]);
  // 'data' is used as state name to make it general. If 'blogs' is used it becomes specific. Now, useFetch can be used in any components to fetch data.

  // While data is being fetched, a loading messages must be displayed:
  const [isLoading, setIsLoading] = useState(true);

  // In case of any error while fetching data:
  const [error, setError] = useState(null);

  useEffect(() => {
    // In this case, data is fetched from local machine. So, it is very fast. But, in actual case, data will be fetched from a server over the internet, which will be having a delay. So, to mimic that, 'setTimeOut' function is used to mimic a delay of one second. Note that it shall not be done in an actual project as it adds another second of delay!!

    setTimeout(() => {
      // To make useFetch hook generalized, instead of hard-coding the url, it is made dynamic as 'url'. Also, 'url' is used as dependency array for useEffect as it need to fetch data with change in the url.

      fetch(url)
        // Note that, for simulating errors 'blogs' is changed to anything else like 'blogss' in the fetch url above.

        .then((res) => {
          // There could be errors in two ways. One, if the request has not reached the server at all, other is if the request has reached the server and server sent the response object but it has some errors or issues. In first case, error will be automatically generated by system. In the second case, "ok" property of response object must be checked if it is "true". If not, an error must be "thrown" which will be caught in ".catch" and displayed on the browser:

          if (!res.ok) {
            throw Error('Could not fetch the data');
          }

          return res.json();
        })
        .then((data) => {
          setData(data);
          setIsLoading(false);

          // With subsequent request to server after errors, data could be fetched. On successful data fetch, the error state must be set back to null:
          setError(null);
        })
        .catch((err) => {
          // In case of an error, loading msg is not to be displayed:
          setIsLoading(false);

          // Value of message to be set to 'error' state:
          setError(err.message);
        });
    }, 1000);
  }, [url]);

  // useFetch returns data, isLoading, and error states as an object:
  return { data, isLoading, error };
  // The above can be returned as an array too. But, returned as an object as the order of the values returned doesn't matter in objects.

  /*
  // The above can be done using Async/Await as well as follows:
  
  useEffect(() => {
    const fetchTasks = async () => {
      const res = await fetch('http://localhost:5000/blogs');
      const data = await res.json();
      setBlogs(data);
    };
    fetchTasks();
  }); 
  */
};

export default useFetch;
