// useFetch is a custom hook created by us to fetch data from any url so that this will be more reusable. When a custom hook is created, its name should start as 'use' so that react understands this js file as a hook. Hook is also a function, which is exported at the end. Note it returns some values as any other hook would do.

import { useState } from 'react';
import { useEffect } from 'react';

const useFetch = (url) => {
  // Initial state of blogs to display on homepage:
  const [data, setData] = useState([]);
  // 'data' is used as state name to make it general. If 'blogs' is used it becomes specific. Now, useFetch can be used in any components to fetch data.

  // While data is being fetched, a loading messages must be displayed:
  const [isLoading, setIsLoading] = useState(true);

  // In case of any error while fetching data:
  const [error, setError] = useState(null);

  useEffect(() => {
    // In this case, data is fetched from local machine. So, it is very fast. But, in actual case, data will be fetched from a server over the internet, which will be having a delay. So, to mimic that, 'setTimeOut' function is used to mimic a delay of one second. Note that it shall not be done in an actual project as it adds another second of delay!!

    // When switched between Home and Create pages quickly (note that this problem may occur or may not), an error occurs which says "cannot perform a react state update on an unmounted component". This means, by the time useFetch has gathered the data, view is shifted to Create from Home. This error is handled by using "AbortController" by pausing (aborting) the fetch:

    const abortCont = new AbortController();

    setTimeout(() => {
      // To make useFetch hook generalized, instead of hard-coding the url, it is made dynamic as 'url'. Also, 'url' is used as dependency array for useEffect as it need to fetch data with change in the url.

      // AbortController is used as a second argument to fetch:
      fetch(url, { signal: abortCont.signal })
        // Note that, for simulating errors 'blogs' is changed to anything else like 'blogss' in the fetch url above.

        .then((res) => {
          // There could be errors in two ways. One, if the request has not reached the server at all, other is if the request has reached the server and server sent the response object but it has some errors or issues. In first case, error will be automatically generated by system. In the second case, "ok" property of response object must be checked if it is "true". If not, an error must be "thrown" which will be caught in ".catch" and displayed on the browser:

          if (!res.ok) {
            throw Error('Could not fetch the data');
          }

          return res.json();
        })
        .then((data) => {
          setData(data);
          setIsLoading(false);

          // With subsequent request to server after errors, data could be fetched. On successful data fetch, the error state must be set back to null:
          setError(null);
        })
        .catch((err) => {
          // When fetch is aborted, fetch throws an error. This is a specific type of error (AbortError) caused by us. But, after catching this error setIsLoading and setError states are updated below (as done for any other error). But, for this error, these states should not be updated. This is done by using if-else statement:

          if (err.name === 'AbortError') {
            console.log('fetch aborted');
          } else {
            // In case of an error, loading msg is not to be displayed:
            setIsLoading(false);

            // Value of message to be set to 'error' state:
            setError(err.message);
          }
        });
    }, 1000);

    // Abort is used here as cleanup function:
    return () => abortCont.abort();
  }, [url]);

  // useFetch returns data, isLoading, and error states as an object:
  return { data, isLoading, error };
  // The above can be returned as an array too. But, returned as an object as the order of the values returned doesn't matter in objects.

  /*
  // The above can be done using Async/Await as well as follows:
  
  useEffect(() => {
    const fetchTasks = async () => {
      const res = await fetch('http://localhost:5000/blogs');
      const data = await res.json();
      setBlogs(data);
    };
    fetchTasks();
  }); 
  */
};

export default useFetch;
