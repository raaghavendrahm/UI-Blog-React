{"version":3,"sources":["components/Navbar.js","components/BlogList.js","components/Home.js","components/useFetch.js","components/Create.js","components/BlogDetails.js","components/NotFound.js","App.js","index.js"],"names":["Navbar","className","to","BlogList","blogs","title","map","blog","id","author","Home","useFetch","url","useState","data","setData","isLoading","setIsLoading","error","setError","useEffect","abortCont","AbortController","setTimeout","fetch","signal","then","res","ok","Error","json","catch","err","name","console","log","message","abort","Create","setTitle","body","setBody","setAuthor","history","useHistory","onSubmit","e","preventDefault","method","headers","JSON","stringify","push","type","required","value","onChange","target","disabled","BlogDetails","useParams","onClick","NotFound","App","exact","path","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.49503abd.chunk.js","sourcesContent":["import { Link } from 'react-router-dom';\n\nconst Navbar = () => {\n  return (\n    <nav className=\"navbar\">\n      <h1>The UI Blog</h1>\n      <div className=\"links\">\n        <Link to=\"/\">Home</Link>\n        <Link to=\"/create\">New Blog</Link>\n      </div>\n    </nav>\n  );\n};\n\nexport default Navbar;\n","import { Link } from 'react-router-dom';\n\nconst BlogList = ({ blogs, title }) => {\n  return (\n    <div className=\"blog-list\">\n      <h2>{title}</h2>\n      {blogs.map((blog) => (\n        <div className=\"blog-preview\" key={blog.id}>\n          <Link to={`blogs/${blog.id}`}>\n            <h2>{blog.title}</h2>\n            <p>Written by {blog.author}</p>\n          </Link>\n          {/* So, id is captured in the links and accessing that inside BlogDetails component. */}\n        </div>\n      ))}\n    </div>\n  );\n};\n\nexport default BlogList;\n","import BlogList from './BlogList';\n\nconst Home = ({ blogs }) => {\n  return (\n    <div className=\"home\">\n      <BlogList blogs={blogs} title=\"All Blogs\" />\n    </div>\n  );\n};\n\nexport default Home;\n","// useFetch is a custom hook created by us to fetch data from any url so that this will be more reusable. When a custom hook is created, its name should start as 'use' so that react understands this js file as a hook. Hook is also a function, which is exported at the end. Note it returns some values as any other hook would do.\n\nimport { useState } from 'react';\nimport { useEffect } from 'react';\n\nconst useFetch = (url) => {\n  // Initial state of blogs to display on homepage:\n  const [data, setData] = useState([]);\n  // 'data' is used as state name to make it general. If 'blogs' is used it becomes specific. Now, useFetch can be used in any components to fetch data.\n\n  // While data is being fetched, a loading messages must be displayed:\n  const [isLoading, setIsLoading] = useState(true);\n\n  // In case of any error while fetching data:\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    // In this case, data is fetched from local machine. So, it is very fast. But, in actual case, data will be fetched from a server over the internet, which will be having a delay. So, to mimic that, 'setTimeOut' function is used to mimic a delay of one second. Note that it shall not be done in an actual project as it adds another second of delay!!\n\n    // When switched between Home and Create pages quickly (note that this problem may occur or may not), an error occurs which says \"cannot perform a react state update on an unmounted component\". This means, by the time useFetch has gathered the data, view is shifted to Create from Home. This error is handled by using \"AbortController\" by pausing (aborting) the fetch:\n\n    const abortCont = new AbortController();\n\n    setTimeout(() => {\n      // To make useFetch hook generalized, instead of hard-coding the url, it is made dynamic as 'url'. Also, 'url' is used as dependency array for useEffect as it need to fetch data with change in the url.\n\n      // AbortController is used as a second argument to fetch:\n      fetch(url, { signal: abortCont.signal })\n        // Note that, for simulating errors 'blogs' is changed to anything else like 'blogss' in the fetch url above.\n\n        .then((res) => {\n          // There could be errors in two ways. One, if the request has not reached the server at all, other is if the request has reached the server and server sent the response object but it has some errors or issues. In first case, error will be automatically generated by system. In the second case, \"ok\" property of response object must be checked if it is \"true\". If not, an error must be \"thrown\" which will be caught in \".catch\" and displayed on the browser:\n\n          if (!res.ok) {\n            throw Error('Could not fetch the data');\n          }\n\n          return res.json();\n        })\n        .then((data) => {\n          setData(data);\n          setIsLoading(false);\n\n          // With subsequent request to server after errors, data could be fetched. On successful data fetch, the error state must be set back to null:\n          setError(null);\n        })\n        .catch((err) => {\n          // When fetch is aborted, fetch throws an error. This is a specific type of error (AbortError) caused by us. But, after catching this error setIsLoading and setError states are updated below (as done for any other error). But, for this error, these states should not be updated. This is done by using if-else statement:\n\n          if (err.name === 'AbortError') {\n            console.log('fetch aborted');\n          } else {\n            // In case of an error, loading msg is not to be displayed:\n            setIsLoading(false);\n\n            // Value of message to be set to 'error' state:\n            setError(err.message);\n          }\n        });\n    }, 1000);\n\n    // Abort is used here as cleanup function:\n    return () => abortCont.abort();\n  }, [url]);\n\n  // useFetch returns data, isLoading, and error states as an object:\n  return { data, isLoading, error };\n  // The above can be returned as an array too. But, returned as an object as the order of the values returned doesn't matter in objects.\n\n  /*\n  // The above can be done using Async/Await as well as follows:\n  \n  useEffect(() => {\n    const fetchTasks = async () => {\n      const res = await fetch('http://localhost:5000/blogs');\n      const data = await res.json();\n      setBlogs(data);\n    };\n    fetchTasks();\n  }); \n  */\n};\n\nexport default useFetch;\n","import { useState } from 'react';\n\n// To redirect to different routes, useHistory hook is required. This is used to re-direct user from Create to Home once a blog is added:\nimport { useHistory } from 'react-router';\n\nconst Create = () => {\n  // It is important to track user input in the form and use it as a state. User input is tracked with 'value' property in input fields. Change in the input is tracked with 'onChange' property that triggers the setState method for that state in an anonymous function. Later this new blog added will be updated to db.json file.\n\n  // Initial state is set to empty string and later updated with the user input value:\n  const [title, setTitle] = useState('');\n  const [body, setBody] = useState('');\n  const [author, setAuthor] = useState('makku');\n\n  // Initial state for loading (this state is specific for Create component) is set to false as the request is sent after sumbitting the form:\n  const [isLoading, setIsLoading] = useState(false);\n\n  // useHistory hook is used to redirect user from Create to Home once a blog is added:\n  const history = useHistory();\n  // useHistory is used to navigate in the browser like back and forward arrows in browser. With 'history.go(-1)' it takes to 1 path backward and 'history.go(1)' takes to 1 path forward w.r.t current path. To take to Home from Create, 'history.push('/')' is used in fetch.\n\n  // Handle Submit\n  const handleSubmit = (e) => {\n    // default behaviour of submission is prevented that prevents page refresh, and the form input values are tracked and used to create 'blog' object that is updated to db.json later:\n    e.preventDefault();\n\n    const blog = { title, body, author };\n    // 'id' is also needed for a blog object but is not created here as it will be automatically generated by json-server during a POST request.\n\n    // console.log(blog); // new object created is logged\n\n    // On sumbitting, POST request is triggered below and now isLoading state must be set to 'true' as it takes time:\n    setIsLoading(true);\n\n    // Add new blog created, with POST request:\n    fetch('http://localhost:5000/blogs', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(blog),\n\n      // json-server adds 'id' property automatically with this.\n    }).then(() => {\n      console.log('new blog added');\n\n      // Once the request is completed here, isLoading must be set to 'false':\n      setIsLoading(false);\n\n      // Redirecting user from Create to Home from Creat on adding a blog:\n      history.push('/');\n    });\n  };\n\n  return (\n    <div className=\"create\">\n      <h2>Add a new blog</h2>\n\n      {/* On form submission, handleSubmit function is triggered that creates 'blog' object which is then updated to db.json with POST request: */}\n      <form onSubmit={handleSubmit}>\n        <label>Blog Title:</label>\n        <input\n          type=\"text\"\n          required\n          value={title} // user input for title is tracked\n          onChange={(e) => setTitle(e.target.value)} // state is updated to user input value\n        />\n\n        <label>Blog Body:</label>\n        <textarea\n          type=\"text\"\n          required\n          value={body} // user input for body is tracked\n          onChange={(e) => setBody(e.target.value)} // state is updated to user input value\n        ></textarea>\n\n        <label>Blog Author:</label>\n        <select value={author} onChange={(e) => setAuthor(e.target.value)}>\n          <option value=\"raaghu\">raaghu</option>\n          <option value=\"raani\">raani</option>\n          <option value=\"makku\">makku</option>\n        </select>\n\n        {/* If isLoading is false, button must say 'Add Blog' and enabled. If false, the button must say 'Adding Blog...' and diabled: */}\n\n        {!isLoading && <button>Add Blog</button>}\n        {isLoading && <button disabled>Adding Blog...</button>}\n\n        {/* To check if the values are getting tracked by displaying: */}\n        {/* <p>{title}</p>\n        <p>{body}</p>\n        <p>{author}</p> */}\n      </form>\n    </div>\n  );\n};\n\nexport default Create;\n","import { useParams } from 'react-router';\n// useParams hook allows us to grab route parameters from the route. That is, if the path showing in the current view is ../blogs/478, then useParams helps us to grab '478'. With this, we can fetch blog with id of 478 and render it.\n\nimport useFetch from './useFetch';\n// As useFetch is made reusable, the same component is used to display a particular blog by feeding in corresponding url to useFetch.\n\nimport { useHistory } from 'react-router';\n// useHistory is used to redirect user from BlogDetails to Home page once blog is deleted.\n\nconst BlogDetails = () => {\n  // Let's destructure the parameter needed from useParams (id in this case):\n  const { id } = useParams();\n\n  // As the access for the parameter is avalilable, now a 'Link' is added in BlogList component to fetch the specific blog details on clicking it. For this, a part of the value of 'to' property is made dynamic w.r.t the id parameter grabbed.\n\n  // data, isLoading, and error are destructured from useFetch for speific url:\n  const {\n    data: blog,\n    isLoading,\n    error,\n  } = useFetch('http://localhost:5000/blogs/' + id);\n  // 'id' is obtained from useParams hook and is used in url dynamically to access specific blog.\n\n  // Initialize useHistory():\n  const history = useHistory();\n\n  // Delete Blog\n\n  const handleDelete = () => {\n    fetch('http://localhost:5000/blogs/' + blog.id, {\n      // 'id' value is received in two ways. One from data (blog) from useFetch and other is 'id' from useParams. Here 'blog.id' is used which is from the first way. But, it can be 'id' which is from second way.\n\n      method: 'DELETE',\n    }).then(() => {\n      // Redirect user to Home page once the blog is deleted:\n      history.push('/');\n    });\n  };\n\n  return (\n    <div className=\"blog-details\">\n      {isLoading && <div>Loading...</div>}\n      {error && <div>{error}</div>}\n      <article>\n        <h2>{blog.title}</h2>\n        <p>Written by {blog.author}</p>\n        <div>{blog.body}</div>\n\n        {/* To delete a blog, a button is used. On clicking it, that blog will be deleted from db.json with DELETE request through fetch: */}\n        <button onClick={handleDelete}>Delete Blog</button>\n      </article>\n    </div>\n  );\n};\n\nexport default BlogDetails;\n","import { Link } from 'react-router-dom';\n\nconst NotFound = () => {\n  return (\n    <div className=\"not-found\">\n      <h2>Sorry</h2>\n      <p>That page cannot be found</p>\n      <Link to=\"/\">Back to the homepage...</Link>\n    </div>\n  );\n};\n\nexport default NotFound;\n","import Navbar from './components/Navbar';\nimport Home from './components/Home';\nimport useFetch from './components/useFetch';\nimport { BrowserRouter as Router, Route, Switch } from 'react-router-dom';\nimport Create from './components/Create';\nimport BlogDetails from './components/BlogDetails';\nimport NotFound from './components/NotFound';\n\nfunction App() {\n  /* \n  // Delete Blog\n  const handleDelete = (id) => {\n    const newBlogs = blogs.filter((blog) => blog.id !== id);\n    setBlogs(newBlogs);\n\n    // Tasks whose id is not as same as the one which is deleted are displayed. Because filter returns the ones whose condition is true.\n\n    // This deletes blogs only from UI, not from database (server). So, on page refresh, they appear back. This is fixed with json-server later.\n  }; \n  */\n\n  // Fetch Blogs\n\n  // Let's destructure the object returned from useFetch:\n  const {\n    data: blogs, // data is received and renamed as 'blogs' as it is passed as props.\n    isLoading,\n    error,\n  } = useFetch('http://localhost:5000/blogs');\n\n  return (\n    <Router>\n      <div className=\"App\">\n        <Navbar />\n        <div className=\"content\">\n          {/* In case of any error while fetching data, error message is displayed: */}\n          {error && <div>{error}</div>}\n\n          {/* While data is not yet fetched, value of 'isLoading' state will be 'true' and this condition should display 'Loading...' message: */}\n          {isLoading && <div>Loading...</div>}\n\n          {/* Once the data is fetched, the value of 'isLoading' state must be changed to 'false' and that should stop diplaying 'Loading...' message. This is taken care in 'Fetch Blogs' section. */}\n          <Switch>\n            <Route exact path=\"/\">\n              <Home blogs={blogs} />\n            </Route>\n\n            <Route path=\"/create\">\n              <Create />\n            </Route>\n\n            {/* Sometimes its needed to pass dynamic values as part of path of route (a route with a certain changeable part). But, regardless of changeable part, it still renders the same component. For example, whether it displays blog with id of 1 in 'blogs/1' or blog with id of 2 as 'blogs/2', it renders the same component of 'BlogDetails' but with different data of that blog. This changeable part of the route (1 or 2 in this case) are called 'Route Parameters (variable inside a route). In our react app we need to be able to use route parameters, and access those route parameters from our component. For example, in the component we can use these ids to fetch data for that particular blog. First, BlogDetails component to be created, and create a route for it below:*/}\n            <Route path=\"/blogs/:id\">\n              {/* ':' represents a dynamic value. This should take to the details of the blog with that id. But it renders the same component. For ex, right now, if the path is ../blogs/1 or ../blogs/346 it renders BlogDetails component. But, to grab the specific id in the path, and render the corresponding blog (instead of showing the same), useParams hook is used in BlogDetails component. */}\n              <BlogDetails />\n            </Route>\n\n            {/* If none of the above route paths are matching, NotFound component is rendered. For this, the path will be '*'. */}\n            <Route path=\"*\">\n              <NotFound />\n            </Route>\n          </Switch>\n        </div>\n      </div>\n    </Router>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}